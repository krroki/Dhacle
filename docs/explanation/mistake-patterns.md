# 🌉 22가지 반복 실수 패턴과 배경 이해

## 📌 문서 관리 지침
**목적**: 반복 실수 패턴 배경 이해 - 왜 이런 규칙이 생겼는지 역사적 경험과 교훈 제공
**대상**: 모든 AI (프로젝트 규칙의 배경 이해가 필요한 경우)
**범위**: 배경 지식과 컴텍스트만 포함 (단계별 해결 방법 없음)
**업데이트 기준**: 신규 실수 패턴 발견 시 즉시 추가
**최대 길이**: 25000 토큰 (현재 약 22000 토큰)
**연관 문서**: [빠른 시작](../tutorial/01-quick-start.md), [현재 상태](../reference/project-status.md)

## ⚠️ 금지사항
- 구체적인 해결 방법이나 구현 단계 추가 금지 (→ how-to/ 문서로 이관)
- 사용법이나 코드 예제 추가 금지 (→ how-to/ 문서로 이관)
- 과도한 기술 세부사항이나 상세 사양 추가 금지 (→ reference/ 문서로 이관)

---

*왜 이런 규칙들이 생겼는지, 어떤 고통스러운 경험을 통해 학습했는지*

**작성 배경**: 2년간 디하클 프로젝트를 진행하며 동일한 실수가 반복적으로 발생하는 것을 발견  
**핵심 교훈**: `"대충 처리 = 2주간 에러 디버깅"`  
**목적**: 새 AI가 같은 실수를 반복하지 않도록 배경 지식 제공

---

## 🤔 왜 이 문서가 필요한가?

### 반복되는 패턴의 발견
프로젝트를 진행하면서 **동일한 실수가 계속 반복**되는 현상을 발견했습니다:
- 새로운 AI 세션마다 같은 실수 
- 임시방편으로 넘어간 코드가 2주 후 대형 버그로 복귀
- 테이블 없이 기능 구현을 시작해서 며칠 후 전체 재작업
- any 타입으로 "빠르게" 해결했다가 나중에 타입 시스템 전체 붕괴

### "2주간 에러 디버깅"의 교훈
2025년 1월, 38개 자동 스크립트로 코드를 일괄 변경했다가 **2주간 에러 지옥**을 경험했습니다. 이때 깨달은 핵심 원칙:
- **임시방편은 기술 부채가 아니라 프로젝트 파괴**
- **"나중에 고치자"는 절대 고쳐지지 않는다**
- **작은 타입 오류 하나가 전체 시스템을 마비시킬 수 있다**

---

## 🔥 가장 치명적인 5가지 패턴

### 1️⃣ 테이블 없이 기능 구현 시작 🔴🔴🔴
**배경**: 기능 구현이 급할 때 "일단 코드부터 짜고 나중에 테이블 생성하자"는 유혹
**결과**: 코드 완성 후 테이블 스키마 변경으로 전체 재작업, 며칠 허비
**교훈**: 데이터베이스 없는 애플리케이션은 뿌리 없는 나무와 같다

### 2️⃣ any 타입 남발 🔴🔴
**배경**: TypeScript 에러가 복잡할 때 "빨리 해결하려고" any 사용
**결과**: 런타임 에러 폭증, 타입 시스템 전체 신뢰도 하락, biome 에러로 빌드 실패
**교훈**: any는 타입 시스템을 무너뜨리는 바이러스

### 3️⃣ profiles vs users 테이블 혼란 🔴🔴
**배경**: profiles VIEW에 없는 naver_cafe 컬럼에 접근 시도
**결과**: 2주간 반복되는 `naver_cafe_nickname not found` 에러  
**교훈**: VIEW와 TABLE의 차이를 명확히 이해해야 함

### 4️⃣ 임시방편 코드 작성 🔴
**배경**: 데드라인 압박으로 "TODO", "임시 데이터", "@ts-ignore" 사용
**결과**: 38개 스크립트 에러 지옥 (2025년 1월), 2주간 디버깅 지옥
**교훈**: 임시방편은 언제나 영구방편이 된다

### 5️⃣ 서버/클라이언트 컨텍스트 혼용 🔴
**배경**: Next.js의 복잡한 렌더링 모델을 이해하지 못한 채 환경변수 사용
**결과**: Hydration 에러, 런타임 크래시, "env.NODE_ENV is not defined"
**교훈**: 서버와 클라이언트는 완전히 다른 실행 환경

---

## 📚 22가지 완전한 패턴 목록

### 0. webpack layout.js 컴파일 에러 → Next.js 빌드 실패 ✅ 완전 해결
**배경**: Next.js의 복잡한 webpack 설정과 Vercel 배포 환경의 차이
**경험**: 2달간 YouTube Lens 500 에러, 무한 컴파일 반복
**교훈**: `output: 'standalone'` 모드가 webpack 의존성 문제를 근본 해결
**해결**: Context7 패턴으로 안정적인 배포 환경 구축

### 1. 서버사이드 환경변수 클라이언트 접근 시도 🔴
**배경**: Next.js의 서버/클라이언트 분리 아키텍처 미이해
**위험성**: 런타임 크래시, 보안 정보 노출 가능성
**교훈**: 환경변수에도 서버/클라이언트 경계가 있다

### 2. 테이블 없이 기능 구현 시작 🔴🔴🔴
**배경**: 개발 속도에 대한 잘못된 이해 ("코드가 먼저")
**현실**: 데이터 구조가 애플리케이션 아키텍처를 결정한다
**교훈**: "기능 구현 = 테이블 먼저"가 실제로 더 빠르다

### 3. @supabase/auth-helpers-nextjs 사용 🔴  
**배경**: 오래된 튜토리얼과 문서로 인한 deprecated 패키지 사용
**문제**: PKCE 인증 실패, OAuth 플로우 불안정
**교훈**: 빠르게 발전하는 생태계에서 최신 패턴 유지 중요성

### 4. React Hook 명명 규칙 위반
**배경**: snake_case 마이그레이션 과정에서 React 규칙 놓침
**현실**: React는 내부적으로 `use`로 시작하는 함수를 특별 처리
**교훈**: 프레임워크 규칙은 프로젝트 컨벤션보다 우선

### 5. TypeScript 컴파일 에러
**배경**: 변수명 리팩토링 과정에서 일관성 부족
**위험성**: 빌드 실패, 타입 체크 우회로 런타임 에러
**교훈**: 리팩토링은 도구로, 수동 변경은 위험

### 6. 런타임 환경 변수 에러
**배경**: Next.js의 복잡한 렌더링 전략과 환경변수 시스템
**문제**: Vercel 빌드 시에만 발생하는 숨겨진 에러
**교훈**: Server Component에서 `force-dynamic` 필수성

### 7. ESLint 에러 (any 타입)
**배경**: TypeScript 학습 초기에 타입 정의의 어려움
**현실**: any는 타입 시스템 전체를 무의미하게 만든다
**교훈**: unknown + 타입 가드가 더 안전하고 명확

### 8. snake_case/camelCase 혼용
**배경**: 데이터베이스(snake_case)와 JavaScript(camelCase) 컨벤션 충돌
**규모**: 47개 API 중 42개에서 변환 미적용 발견
**교훈**: API 경계에서의 일관된 변환 규칙 필요성

### 9. API 연동 미흡 (Direct fetch 사용)
**배경**: 간단한 API 호출에 래퍼 함수 사용이 과도해 보임
**현실**: 인증, 에러 처리, 타입 안전성이 모든 호출에 필요
**교훈**: 중앙화된 API 클라이언트의 중요성

### 10. API 인증 패턴 표준화 완료 ✅ (2025-08-31 검증)
**배경**: 프로젝트에 표준화된 인증 헬퍼 함수 구축됨
**현실**: `requireAuth()` 함수가 `/src/lib/api-auth.ts`에 완전 구현됨
**사용 현황**: 29개 API 라우트에서 `requireAuth()` 사용 (72.5% 표준화)
**내부 구현**: `supabase.auth.getUser()` 기반으로 안전하게 구현
**교훈**: 코드 분석 시 실제 파일 확인 후 문서 작성 필수

### 11. monitoring.ts any 타입 임시 정의 🔴 (2025-08-30)
**배경**: YouTube Data API v3의 복잡한 타입 구조를 빠르게 우회하려는 시도
**위험성**: 6개 any 타입 정의로 전체 모니터링 시스템 타입 안전성 상실
**현실**: API 문서 참조하면 정확한 타입 정의 가능
**교훈**: "빠른 우회"가 실제로는 더 많은 시간 소모

### 12. 동적 테이블 22개 한번에 처리 🔴 (2025-08-30)  
**배경**: 모든 테이블을 Union Type으로 처리하는 것이 "완전하다"는 착각
**문제**: TypeScript 컴파일러 부하 과다, 메모리 사용량 급증
**현실**: 단계적 접근이 실제로 더 안정적이고 빠름
**교훈**: 완전성과 성능 사이의 균형점 찾기

### 13. E2E 테스트 인증 우회 미발견 🟡 (2025-08-27)
**배경**: 실제 OAuth 없이는 E2E 테스트가 불가능하다는 선입견
**현실**: 프로젝트에 이미 완벽한 테스트 로그인 시스템 구현되어 있었음
**발견**: `/api/auth/test-login` 개발 전용 엔드포인트 존재
**교훈**: 문제 해결 전에 기존 시스템 충분히 탐색 필요

### 14. webpack 컴파일 에러 근본 원인 미파악 🔴🔴 (2025-08-29 해결)
**배경**: 2달간 지속된 layout.js 컴파일 에러를 표면적으로만 해결 시도  
**근본 원인**: Next.js webpack 의존성과 Vercel 배포 환경의 불일치
**해결**: Context7 패턴으로 `output: 'standalone'` 모드 적용
**교훈**: 표면적 증상보다 시스템 아키텍처 차원에서 접근

### 10. DB 값 무시하고 임의 생성
**배경**: 실제 데이터 없이 빠른 UI 개발을 위한 모킹
**위험성**: 실제 데이터 구조와 UI의 불일치로 런타임 에러
**교훈**: 실제 데이터로 개발해야 실제 문제를 발견

### 11. any 타입 남발 (에러 처리)
**배경**: JavaScript의 자유로운 에러 처리에 익숙함
**문제**: TypeScript 환경에서는 타입 안전성 필수
**교훈**: unknown + instanceof Error 패턴이 표준

### 12. 파일 컨텍스트 무시
**배경**: "대략 이런 패턴일 것" 이라는 추측성 개발
**위험성**: 기존 코드 스타일과 불일치로 유지보수 어려움
**교훈**: Read → 이해 → Edit 순서 준수

### 13. Supabase 패턴 혼용
**배경**: Supabase 생태계의 빠른 변화와 마이그레이션
**문제**: 구식/신식 클라이언트 혼용으로 인증 불안정
**교훈**: 전체 시스템의 일관된 패턴 유지 중요성

### 14. profiles vs users 테이블 혼란 🔴🔴
**배경**: Supabase의 VIEW 시스템과 실제 테이블 구조 차이
**고통**: 2주간 `naver_cafe_nickname not found` 반복 에러
**교훈**: VIEW와 TABLE의 용도와 제약사항 명확한 이해 필요

### 15. 임시방편 코드 작성 🔴
**배경**: 개발 속도 압박과 "나중에 고치자" 심리
**현실**: 임시방편 코드는 절대 고쳐지지 않고 기술부채로 축적
**교훈**: 처음부터 제대로 하는 것이 가장 빠른 방법

### 16. OAuth PKCE 라이브러리 불일치
**배경**: Next.js Auth 생태계의 복잡성과 호환성 문제
**문제**: Kakao 로그인 PKCE 에러, 인증 플로우 실패
**교훈**: OAuth 구현은 전체 플로우의 일관성이 핵심

### 17. E2E 테스트 런타임 에러 미감지
**배경**: 일반적인 E2E 테스트가 JavaScript 에러를 무시
**위험성**: "테스트 통과"했지만 실제로는 에러가 발생하는 상태
**교훈**: 런타임 에러 감지가 E2E 테스트의 필수 요소

### 18. YouTube API camelCase/snake_case 불일치
**배경**: 외부 API와 내부 시스템 간의 네이밍 컨벤션 차이
**함정**: YouTube API는 camelCase, 내부는 snake_case 사용
**교훈**: API 경계에서의 정확한 데이터 매핑 중요성

### 19. 서브에이전트 이름 혼동 (Task 도구)
**배경**: SuperClaude 페르소나와 Task 도구의 서브에이전트 시스템 구분
**혼란**: `analyzer` 페르소나를 Task 서브에이전트로 잘못 사용
**교훈**: 도구별 시스템과 명명 규칙의 정확한 이해 필요

### 20. E2E 테스트 환경별 설정 무시
**배경**: 개발/테스트/프로덕션 환경 구분 없는 단일 설정
**문제**: 403 Forbidden, 429 Too Many Requests 에러
**교훈**: 환경별 동적 설정이 안정적인 테스트의 기반

### 21. E2E 테스트 중복 파일 생성
**배경**: 기능별로 별도 테스트 파일을 만들어야 한다는 잘못된 인식
**현실**: 90% 중복 코드로 유지보수 불가능
**교훈**: Context7 픽스처 패턴으로 재사용성 극대화

### 22. 검증 기준 과도한 엄격함
**배경**: "완벽한 코드"에 대한 이상주의적 접근
**문제**: 실질적 개선을 반영하지 못하는 평가 시스템
**교훈**: Context7 베스트 프랙티스 기반 현실적 품질 기준

---

## 🛡️ 근본적 예방 접근법

### 능동적 해결 문화
**수동적 회피** (임시방편, TODO, any 타입) → **능동적 해결** (즉시 완전한 구현)

### 16개 서브에이전트 시스템
각 영역별 전문 에이전트가 실시간으로 이러한 실수 패턴을 차단:
- **Database Agent**: 테이블 없는 구현 차단
- **Type Agent**: any 타입 즉시 제거
- **API Route Agent**: 인증 패턴 강제 적용
- **Component Agent**: shadcn/ui 우선 사용
- 기타 12개 전문 에이전트

### 3단계 프로세스
```
STOP - 문제 발견 시 즉시 중단
FIX - 완전한 해결 (임시방편 금지)  
VERIFY - 실제 작동 확인 (npm run verify:parallel)
```

---

## 💡 배운 교훈들

### 기술적 교훈
1. **데이터베이스가 애플리케이션 아키텍처를 결정한다**
2. **타입 시스템은 전체가 안전해야 의미가 있다**
3. **환경변수도 아키텍처다**
4. **프레임워크 규칙은 프로젝트 컨벤션보다 우선한다**
5. **API 경계에서 모든 변환이 일어나야 한다**

### 개발 문화 교훈
1. **임시방편은 절대 고쳐지지 않는다**
2. **"나중에"는 절대 오지 않는다**
3. **작은 타입 오류가 큰 시스템 장애로 이어진다**
4. **도구가 사람보다 일관성이 높다**
5. **예방이 치료보다 1000배 효과적이다**

### 협업 교훈
1. **문서가 없으면 같은 실수가 반복된다**
2. **패턴의 "왜"를 이해해야 준수한다**
3. **자동화된 검증이 인간의 주의력보다 신뢰할 만하다**
4. **실패 경험의 공유가 가장 강력한 교육이다**

---

## 🎯 이 지식의 활용

### 새 AI 온보딩
새로운 AI 세션이 시작될 때 이 배경 지식을 바탕으로:
1. **왜 이런 규칙들이 있는지** 이해
2. **실제 프로젝트 경험에서 나온 지혜** 인식  
3. **같은 실수 반복 방지** 의식
4. **능동적 문제 해결** 자세 견지

### 실무 적용
실제 개발 과정에서:
- 임시방편의 유혹을 느낄 때 → "2주간 에러 디버깅" 회상
- 타입 정의가 복잡할 때 → any 타입의 파괴적 결과 기억
- 기능 구현이 급할 때 → 테이블 없는 구현의 허무한 결과 상기

---

**결론**: 이 22가지 패턴은 단순한 규칙이 아니라 **고통스러운 경험을 통해 얻은 생존 지혜**입니다. 각 규칙 뒤에는 실제 프로젝트에서 겪은 구체적인 실패와 그로부터 얻은 교훈이 있습니다.

**다음 단계**: [실무 작업 가이드](../how-to/) 섹션에서 이러한 실수를 방지하는 구체적인 실행 방법을 확인하세요.