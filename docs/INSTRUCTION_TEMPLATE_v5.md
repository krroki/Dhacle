# 📝 100% 구현 성공 지시서 작성 템플릿 v5.0

*개발 지식 없는 사용자 요청도 100% 성공하는 구현으로 만드는 케이스별 최적화 템플릿*

---

## 🚨 최우선 규칙: Claude Code 나쁜 습관 절대 금지

### ❌ 절대 하지 말아야 할 것들
1. **얕은 분석 금지**
   - ❌ "2-3개 파일 확인했으니 전체 확인 완료" → 거짓말
   - ✅ 관련 파일 10개 이상, 유사 패턴 5개 이상 반드시 확인

2. **추측 기반 작업 금지**
   - ❌ "아마도", "추정하건대", "~일 것입니다" → 즉시 중단
   - ✅ 테스트 결과, 파일명:라인번호, 검증 명령어 실행 결과만 신뢰

3. **부분 구현 금지**
   - ❌ 컴포넌트만 만들고 "완료했습니다" → 미완성
   - ✅ UI + API + DB + 타입 + 테스트 + 에러처리 전체 구현

4. **즉시 구현 금지**
   - ❌ 지시서 없이 바로 코드 작성 → 실패 확정
   - ✅ 정보 수집 → 분석 → 지시서 → 확인 → 구현

5. **검증 생략 금지**
   - ❌ 테스트 없이 "작동합니다" → 거짓말
   - ✅ npm run build, verify:all, 실제 동작 확인 필수

### ⚠️ 토큰이 많이 들어도, 시간이 오래 걸려도
> **"한 번에 정확하게 > 여러 번 수정"**
> 3일간 디버깅하느니 30분 깊이 분석하는 것이 낫다

---

## 🎯 이 템플릿의 목적과 사용법

### 목적
개발 지식이 없는 사용자의 모호한 요청을 **100% 성공하는 구현**으로 만들기 위한 체계적 지시서 작성

### 사용 방법
1. **요청 해석**: 아래 [요청 해석 가이드](#요청-해석-가이드)로 케이스 판단
2. **케이스 선택**: 6개 중 적절한 케이스 선택
3. **템플릿 실행**: 해당 케이스의 Phase 순서대로 실행
4. **지시서 작성**: 수집한 정보로 명확한 지시서 작성
5. **확인 후 구현**: 사용자 승인 후 정확히 구현

### 4가지 핵심 원칙 (모든 케이스 공통)
1. **요구사항 명확화**: 사용자 의도를 개발 용어로 정확히 변환
2. **프로젝트 파악**: 13개 문서 + 현재 코드 상태 완전 파악
3. **깊이 있는 분석**: 추측 X, 증거 O, 파일 10개+, 패턴 5개+
4. **상세한 지시서**: 파일명:라인번호까지 구체적으로

---

## 🔍 요청 해석 가이드

### 케이스 판단 플로우차트
```
사용자 요청
    ↓
[정보가 충분한가?]
    No → CLARIFY (명확화)
    Yes ↓
[새로 만드는가?]
    Yes → DEVELOP (개발)
    No ↓
[문제 해결인가?]
    Yes → DEBUG (디버그)
    No ↓
[개선/최적화인가?]
    Yes → IMPROVE (개선)
    No ↓
[분석/조사인가?]
    Yes → ANALYZE (분석)
    No ↓
[설정/환경인가?]
    Yes → CONFIGURE (설정)
```

### 케이스별 키워드
| 케이스 | 키워드 예시 |
|--------|------------|
| **DEVELOP** | 만들어, 추가, 구현, 생성, 개발, 넣어 |
| **DEBUG** | 안 돼, 에러, 오류, 문제, 버그, 고쳐 |
| **IMPROVE** | 개선, 최적화, 리팩토링, 정리, 느려 |
| **ANALYZE** | 왜, 어떻게, 분석, 조사, 이해, 파악 |
| **CONFIGURE** | 설정, 환경, 배포, CI/CD, Docker |
| **CLARIFY** | (정보 부족, 극도로 모호) |

---

## 📑 목차

1. [DEVELOP - 새 기능 개발](#develop---새-기능-개발)
2. [DEBUG - 버그 수정](#debug---버그-수정)
3. [IMPROVE - 개선/최적화](#improve---개선최적화)
4. [ANALYZE - 분석/조사](#analyze---분석조사)
5. [CONFIGURE - 설정/환경](#configure---설정환경)
6. [CLARIFY - 명확화](#clarify---명확화)

---

## DEVELOP - 새 기능 개발

### 📌 특징
- **목적**: 없는 것을 새로 만들기
- **시작점**: 요구사항
- **핵심**: 기존 패턴 분석 → 설계 → 구현

### 📋 Phase 구조

#### Phase 1: 요구사항 심층 분석
```markdown
## 1. 요청 해석
- 원문: "[사용자 요청 그대로]"
- 개발 용어 변환: [명확한 기술 요구사항으로]
- 범위: UI [ ], API [ ], DB [ ], 기타 [ ]

## 2. 프로젝트 현황 파악
### 13개 문서 확인
□ PROJECT.md - 현재 이슈
□ CODEMAP.md - 파일 구조
□ WIREFRAME.md - UI-API 연결
□ COMPONENT_INVENTORY.md - 재사용 가능 컴포넌트
□ ROUTE_SPEC.md - 라우트 구조
□ STATE_FLOW.md - 상태 관리
□ DATA_MODEL.md - 데이터 타입

## 3. 필요 정보 구체화
- 위치: 어느 페이지/컴포넌트?
- 기능: 구체적 동작은?
- 데이터: 어떤 데이터 필요?
- 권한: 인증 필요?
- UI: 디자인 요구사항?
```

#### Phase 2: 기존 코드 패턴 분석 (테스트 X, 패턴 O)
```markdown
## 1. 유사 기능 탐색 (10개 이상!)
```bash
# 관련 컴포넌트 찾기
find src/components -name "*.tsx" | xargs grep -l "비슷한기능"

# API 패턴 찾기
grep -r "POST\|GET\|PUT" src/app/api --include="*.ts"

# 상태 관리 패턴
grep -r "useState\|useEffect" src/ --include="*.tsx"
```

## 2. 패턴 분석 (5개 이상!)
### 발견한 패턴
1. [컴포넌트명]: [패턴 설명]
2. [API 라우트]: [구조 설명]
3. [상태 관리]: [방식 설명]
4. [에러 처리]: [패턴 설명]
5. [타입 정의]: [구조 설명]

## 3. 재사용 가능 요소
- shadcn/ui 컴포넌트: [ ]
- 유틸리티 함수: [ ]
- 공통 훅: [ ]
```

#### Phase 3: 구현 설계
```markdown
## 1. 아키텍처 설계
### 컴포넌트 구조
- 메인 컴포넌트: [경로/이름]
- 하위 컴포넌트: [필요시]
- 상태 관리: [전역/로컬]

### API 설계
- 엔드포인트: [경로]
- 메소드: [GET/POST/PUT/DELETE]
- 요청/응답 타입: [정의]

### DB 스키마
- 테이블: [필요시]
- RLS 정책: [보안]

## 2. 구현 순서
1. [ ] 타입 정의
2. [ ] API 라우트
3. [ ] UI 컴포넌트
4. [ ] 상태 연결
5. [ ] 에러 처리
6. [ ] 테스트
```

#### Phase 4: 지시서 작성 및 확인
```markdown
## 📋 구현 지시서

### 작업 범위
✅ 포함:
- [구체적 파일/기능 목록]

❌ 제외:
- [범위 밖 항목]

### 구현 단계
Step 1: 타입 정의
```typescript
// src/types/index.ts
interface NewFeature {
  // 구체적 타입
}
```

Step 2: API 구현
```typescript
// src/app/api/[경로]/route.ts
// 참고: src/app/api/[유사]/route.ts
```

Step 3: UI 구현
```typescript
// src/components/[경로]/[이름].tsx
// 참고: src/components/[유사].tsx
```

### 성공 기준
□ npm run build 성공
□ npm run verify:all 통과
□ 기능 정상 작동
□ 에러 처리 완벽

### 예상 결과
- 정상 동작: [설명]
- 에러 시: [처리 방법]

**이대로 진행할까요?**
```

#### Phase 5: 구현
```markdown
승인 후:
1. 지시서 순서대로 구현
2. 각 단계 후 검증
3. 전체 테스트
4. 문서 업데이트
```

---

## DEBUG - 버그 수정

### 📌 특징
- **목적**: 작동하지 않는 것 수정
- **시작점**: 증상/에러
- **핵심**: 재현 → 원인 분석 → 수정

### 📋 Phase 구조

#### Phase 1: 문제 상황 파악
```markdown
## 1. 증상 수집
- 사용자 보고: "[원문 그대로]"
- 발생 시점: 언제?
- 발생 위치: 어디서?
- 영향 범위: 어느 정도?

## 2. 재현 시도
```bash
npm run dev
# 1. 해당 페이지 접근
# 2. 문제 동작 수행
# 3. Console 확인
# 4. Network 탭 확인
```

## 3. 초기 진단
```bash
npm run verify:all
npm run test
npm run build
```
```

#### Phase 2: 원인 분석 (깊이!)
```markdown
## 1. 에러 추적
```bash
# 에러 메시지로 검색
grep -r "에러메시지" src/ --include="*.ts" --include="*.tsx"

# 관련 컴포넌트 확인
find src -name "*관련*" -type f | head -20
```

## 2. 코드 분석 (10개 파일 이상!)
### 확인한 파일들
1. [파일명:라인] - [발견 내용]
2. [파일명:라인] - [발견 내용]
... (10개 이상)

## 3. 근본 원인
- 직접 원인: [코드 레벨]
- 근본 원인: [설계 레벨]
- 영향 범위: [다른 부분]
```

#### Phase 3: 해결책 도출
```markdown
## 1. 가능한 해결 방법들
### 방법 A: [간단한 수정]
- 장점: 빠름
- 단점: 임시방편

### 방법 B: [근본 해결]
- 장점: 완벽
- 단점: 시간 소요

## 2. 권장 해결책
- 선택: 방법 [A/B]
- 이유: [명확한 근거]

## 3. 수정 계획
1. [ ] [파일1] 수정
2. [ ] [파일2] 수정
3. [ ] 테스트
4. [ ] 검증
```

#### Phase 4: 수정 지시서 및 확인
```markdown
## 📋 버그 수정 지시서

### 문제 요약
- 증상: [사용자 관점]
- 원인: [기술적 원인]
- 해결: [수정 방법]

### 수정 내용
```typescript
// [파일명:라인]
// 현재 코드
const current = broken;

// 수정할 코드
const fixed = working;
```

### 영향 범위
- 직접 수정: [파일 목록]
- 간접 영향: [확인 필요]

### 테스트 계획
□ 버그 재현 불가 확인
□ 다른 기능 정상 확인
□ 새로운 에러 없음

**이대로 수정할까요?**
```

#### Phase 5: 수정 및 검증
```markdown
승인 후:
1. 백업 (필요시)
2. 수정 실행
3. 테스트
4. 검증
```

---

## IMPROVE - 개선/최적화

### 📌 특징
- **목적**: 작동하는 것을 더 좋게
- **시작점**: 현재 상태
- **핵심**: 측정 → 개선점 → 적용

### 📋 Phase 구조

#### Phase 1: 현재 상태 측정
```markdown
## 1. 개선 대상
- 요청: "[사용자 원문]"
- 대상: [구체적 범위]
- 목표: [개선 목표]

## 2. 현재 성능/품질 측정
### 성능 지표
```bash
npm run build
# 번들 크기 확인
# 빌드 시간 확인
```

### 코드 품질
```bash
npm run lint:biome
npm run verify:all
```

### 사용자 경험
- 로딩 시간: [ ]초
- 반응 속도: [ ]
- 에러 빈도: [ ]

## 3. 문제점 도출
1. [측정 가능한 문제 1]
2. [측정 가능한 문제 2]
```

#### Phase 2: 개선 가능 영역 분석
```markdown
## 1. 코드 분석 (20개 파일 이상!)
```bash
# 중복 코드 찾기
# 비효율 패턴 찾기
# 미사용 코드 찾기
```

## 2. 개선 기회
### 성능 개선
- [ ] 번들 크기 감소
- [ ] 렌더링 최적화
- [ ] API 호출 감소

### 코드 품질
- [ ] 중복 제거
- [ ] 복잡도 감소
- [ ] 가독성 향상

### 유지보수성
- [ ] 컴포넌트 분리
- [ ] 타입 안정성
- [ ] 테스트 커버리지
```

#### Phase 3: 개선 계획 수립
```markdown
## 1. 개선 우선순위
1. [영향도 높음 + 쉬움]
2. [영향도 높음 + 어려움]
3. [영향도 낮음 + 쉬움]

## 2. 단계별 계획
### Phase 1: Quick Win
- [ ] [즉시 개선 가능]

### Phase 2: 주요 개선
- [ ] [핵심 개선 사항]

### Phase 3: 장기 개선
- [ ] [시간 필요한 것]

## 3. 위험 요소
- 부작용: [가능한 문제]
- 대응책: [해결 방법]
```

#### Phase 4: 개선 지시서 및 확인
```markdown
## 📋 개선 지시서

### 개선 범위
- 대상: [파일/기능]
- 목표: [측정 가능한 목표]

### 개선 내용
1. [개선 1]
   - 현재: [문제]
   - 개선: [해결]
   - 효과: [측정값]

2. [개선 2]
   ...

### 예상 결과
- 성능: [전] → [후]
- 품질: [전] → [후]

**이대로 개선할까요?**
```

---

## ANALYZE - 분석/조사

### 📌 특징
- **목적**: 이해와 파악
- **시작점**: 질문/호기심
- **핵심**: 수집 → 분석 → 인사이트

### 📋 Phase 구조

#### Phase 1: 분석 목적 명확화
```markdown
## 1. 분석 요청
- 질문: "[사용자 원문]"
- 목적: 왜 알고 싶은가?
- 활용: 어떻게 사용할 것인가?

## 2. 분석 범위
- 대상: [코드/시스템/데이터]
- 깊이: [표면/중간/심층]
- 기간: [특정 기간/전체]
```

#### Phase 2: 데이터 수집 (광범위!)
```markdown
## 1. 파일 수집 (20개 이상!)
```bash
# 모든 관련 파일 찾기
find src -type f -name "*" | grep -E "패턴"

# 코드 패턴 수집
grep -r "분석대상" src/ --include="*.ts" --include="*.tsx"
```

## 2. 수집 데이터
### 파일 목록
1. [파일1] - [관련성]
2. [파일2] - [관련성]
... (20개 이상)

### 패턴 발견
- 패턴 1: [설명]
- 패턴 2: [설명]
```

#### Phase 3: 분석 및 인사이트
```markdown
## 1. 정량 분석
- 파일 수: [ ]
- 코드 라인: [ ]
- 복잡도: [ ]
- 의존성: [ ]

## 2. 정성 분석
### 구조 분석
- 아키텍처: [설명]
- 패턴: [설명]

### 문제점
1. [발견한 문제]
2. [개선 기회]

## 3. 인사이트
- 핵심 발견: [중요한 것]
- 권장사항: [제안]
```

#### Phase 4: 분석 보고서
```markdown
## 📊 분석 결과 보고

### 요약
- 질문: [원래 질문]
- 답변: [핵심 답변]

### 상세 분석
[구체적 내용]

### 근거 자료
- 파일: [목록]
- 데이터: [수치]

### 결론 및 제안
[실행 가능한 제안]
```

---

## CONFIGURE - 설정/환경

### 📌 특징
- **목적**: 환경과 설정 구성
- **시작점**: 요구사항
- **핵심**: 현재 → 목표 → 설정

### 📋 Phase 구조

#### Phase 1: 요구사항 파악
```markdown
## 1. 설정 요구
- 요청: "[사용자 원문]"
- 목적: [왜 필요한가]
- 환경: [개발/스테이징/프로덕션]

## 2. 현재 설정 확인
```bash
# 환경 변수
cat .env.local

# 설정 파일
ls -la *.config.js *.json

# 패키지
cat package.json
```

## 3. 영향 범위
- 영향받는 기능: [ ]
- 필요한 권한: [ ]
- 위험 요소: [ ]
```

#### Phase 2: 설정 계획
```markdown
## 1. 필요한 변경
### 파일 수정
- [ ] [설정 파일 1]
- [ ] [설정 파일 2]

### 환경 변수
- [ ] 추가: [KEY=VALUE]
- [ ] 수정: [KEY=NEW_VALUE]

### 패키지
- [ ] 설치: [패키지명]
- [ ] 업데이트: [패키지명]

## 2. 순서
1. 백업
2. 설정 변경
3. 테스트
4. 롤백 준비
```

#### Phase 3: 설정 지시서 및 확인
```markdown
## 📋 설정 지시서

### 변경 내용
1. [파일명]
```json
// 변경 전
"old": "value"

// 변경 후
"new": "value"
```

### 실행 명령
```bash
# 1. 백업
cp [파일] [파일].backup

# 2. 변경
[명령어]

# 3. 검증
[테스트 명령]
```

### 롤백 계획
```bash
# 문제 발생 시
cp [파일].backup [파일]
```

**이대로 설정할까요?**
```

---

## CLARIFY - 명확화

### 📌 특징
- **목적**: 모호한 요청 구체화
- **시작점**: 정보 부족
- **핵심**: 질문 → 정보 → 재분류

### 📋 Phase 구조

#### Phase 1: 초기 정보 파악
```markdown
## 1. 받은 요청
- 원문: "[사용자 원문]"
- 키워드: [추출한 키워드]
- 추측 가능한 의도: [가능성들]

## 2. 부족한 정보
- [ ] 무엇을? (대상)
- [ ] 어디에? (위치)
- [ ] 언제? (시점)
- [ ] 왜? (목적)
- [ ] 어떻게? (방법)
```

#### Phase 2: 구체화 질문
```markdown
## 필요한 정보를 위한 질문

요청하신 "[원문]"을 정확히 이해하기 위해 확인이 필요합니다:

### 1. 작업 대상
❓ 어느 페이지/기능에 대한 요청인가요?
   - 예시: 마이페이지, YouTube Lens, 로그인 화면

### 2. 구체적 동작
❓ 어떤 동작을 원하시나요?
   - A안: [가능한 해석 1]
   - B안: [가능한 해석 2]
   - C안: [가능한 해석 3]

### 3. 예상 결과
❓ 완성된 모습이 어떤가요?
   - 예시: "버튼 클릭 시 모달 열림"

### 4. 추가 요구사항
❓ 특별히 고려할 사항이 있나요?
   - 디자인, 권한, 성능 등

### 5. 참고 자료
❓ 참고할 만한 예시가 있나요?
   - 웹사이트, 스크린샷 등
```

#### Phase 3: 정보 수집 후 재분류
```markdown
## 추가 정보
[사용자 답변 기록]

## 케이스 재분류
수집한 정보를 바탕으로 → [DEVELOP/DEBUG/IMPROVE/ANALYZE/CONFIGURE] 케이스로 이동

## 다음 단계
해당 케이스의 Phase 1부터 시작
```

---

## 🎯 케이스별 성공 체크리스트

### DEVELOP
- [ ] 요구사항 100% 명확
- [ ] 유사 패턴 5개 이상 분석
- [ ] UI + API + DB 전체 설계
- [ ] 재사용 컴포넌트 확인
- [ ] 테스트 계획 포함

### DEBUG
- [ ] 문제 재현 성공
- [ ] 원인 파일:라인 특정
- [ ] 영향 범위 파악
- [ ] 근본 원인 분석
- [ ] 재발 방지책 포함

### IMPROVE
- [ ] 현재 상태 측정값
- [ ] 개선 목표 수치화
- [ ] 20개 이상 파일 분석
- [ ] 위험 요소 파악
- [ ] 롤백 계획 준비

### ANALYZE
- [ ] 분석 목적 명확
- [ ] 20개 이상 데이터
- [ ] 정량/정성 분석
- [ ] 실행 가능한 인사이트
- [ ] 근거 자료 첨부

### CONFIGURE
- [ ] 현재 설정 백업
- [ ] 영향 범위 확인
- [ ] 순차적 적용 계획
- [ ] 검증 방법 준비
- [ ] 롤백 절차 문서화

### CLARIFY
- [ ] 5개 이상 구체적 질문
- [ ] 예시 제공
- [ ] 옵션 제시
- [ ] 재분류 준비

---

## 📊 검증 명령어 모음

```bash
# 필수 검증
npm run verify:all
npm run build
npm run test

# 개별 검증
npm run verify:api      # API 일치성
npm run verify:types    # 타입 안정성
npm run verify:routes   # 라우트 보호
npm run verify:ui       # UI 일관성

# 품질 검증
npm run lint:biome
npm run test:coverage

# 보안 검증
npm run security:test
```

---

## 🚨 최종 주의사항

1. **깊이 > 속도**: 3일 디버깅 < 30분 깊은 분석
2. **증거 > 추측**: 테스트 결과만 신뢰
3. **전체 > 부분**: 시스템 전체 고려
4. **명확 > 모호**: 파일명:라인번호까지
5. **검증 > 가정**: 실제로 확인한 것만

---

*이 템플릿으로 100% 성공하는 구현 지시서 작성 가능*