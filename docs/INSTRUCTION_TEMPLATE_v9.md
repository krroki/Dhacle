# 🎯 AI 개발 지시서 작성 템플릿 v9.0

**목적**: 개발 지식이 없는 사용자의 지시를 AI가 정확히 이해하고 실행할 수 있는 명확한 지시서로 변환

**이 문서를 읽는 AI의 역할**: 지시서를 작성하는 것 (직접 코드 실행 아님)

---

## 🚨 절대 금지사항 (Claude Code 나쁜 습관 차단)

### ❌ 금지된 행동들
1. **추측 기반 작업** → 반드시 파일 내용 확인 후 작업
2. **부분 코드 제시** → 전체 파일 내용만 제공
3. **"..." 사용** → 완전한 코드만 작성
4. **거짓 정보 생성** → 모르면 "확인 필요" 명시
5. **표면적 수정** → 연관된 모든 파일 확인
6. **섣부른 완료 선언** → 객관적 검증 후에만 완료
7. **패턴화 후 확인 생략** → 모든 항목 개별 확인
8. **토큰 아끼려고 생략** → 완전성이 최우선
9. **하드코딩된 가정** → 프로젝트별 실제 구조 확인
10. **대충 넘어가기** → 모든 단계 증거 기반 실행

### ✅ 필수 수행 원칙
1. **증거 우선**: 모든 결정에 실제 파일 내용 근거
2. **완전성**: 전체 파일, 전체 프로세스
3. **투명성**: 실패는 실패로, 모름은 모름으로
4. **검증 가능**: 구체적 명령과 예상 결과
5. **컨텍스트 유지**: 프로젝트 특성 반영

---

## 📋 공통 섹션

### 1️⃣ 프로젝트 온보딩 (모든 작업 시작 전 필수)

```markdown
## 프로젝트 구조 파악

### 13개 핵심 문서 체계 확인 (우선순위)
1. /CLAUDE.md - AI 작업 지침서 (필수 규칙)
2. /docs/PROJECT.md - 프로젝트 현황과 이슈
3. /docs/CODEMAP.md - 프로젝트 구조와 기술 스택
4. /docs/DATA_MODEL.md - 데이터 모델과 타입 시스템
5. /docs/FLOWMAP.md - 사용자 플로우와 인증 경로
6. /docs/WIREFRAME.md - UI-API 연결 상태
7. /docs/ROUTE_SPEC.md - 라우트 구조와 보호 상태
8. /docs/COMPONENT_INVENTORY.md - 재사용 가능 컴포넌트
9. /docs/STATE_FLOW.md - 상태 관리 패턴
10. /docs/ERROR_BOUNDARY.md - 에러 처리 전략
11. /docs/CHECKLIST.md - 작업 검증 체크리스트
12. /docs/DOCUMENT_GUIDE.md - 문서 가이드라인
13. /docs/INSTRUCTION_TEMPLATE.md - 지시서 템플릿

### 기술 파일 확인 (보조)
- package.json - 기술 스택, 스크립트, 의존성
- tsconfig.json - TypeScript 설정
- tailwind.config.js - 스타일링 설정
- .env.example - 환경 변수 구조

### 프로젝트 특성 파악
- 프레임워크: Next.js (app router 또는 pages router)
- 스타일링: Tailwind CSS 또는 기타
- 상태 관리: Zustand, Redux, 또는 useState
- 데이터베이스: Supabase, Firebase, 또는 기타
- 인증: Supabase Auth, NextAuth, 또는 기타

### 코딩 패턴 확인
- import 스타일 (@/ 절대 경로 사용 여부)
- 컴포넌트 패턴 (Server/Client Components)
- API 패턴 (Route Handlers 또는 API Routes)
- 타입 시스템 (중앙 관리 또는 분산)
```

### 2️⃣ 사용자 지시 해석 (과도한 추론 금지)

```markdown
## 지시 분석

### 명시적 정보 추출
- 작업 대상: [구체적 파일/기능]
- 작업 유형: [수정/추가/삭제/수정]
- 위치: [명시된 경로 또는 "확인 필요"]

### 불명확한 부분 목록
- [ ] 정확한 파일 위치
- [ ] 구체적 동작 방식
- [ ] 예상 결과

### 추가 확인 필요 사항
1. [질문 1]
2. [질문 2]
```

---

## 📑 목차 (바로가기)

1. [버그 수정](#1-버그-수정)
2. [UI/UX 개선](#2-uiux-개선)
3. [기능 추가](#3-기능-추가)
4. [API 수정](#4-api-수정)
5. [성능 최적화](#5-성능-최적화)
6. [스타일 수정](#6-스타일-수정)
7. [보안 수정](#7-보안-수정)
8. [빌드/배포 이슈](#8-빌드배포-이슈)
9. [테스트 추가](#9-테스트-추가)
10. [리팩토링](#10-리팩토링)

---

## 📝 케이스별 상세 템플릿

### 1. 버그 수정

```markdown
## 버그 수정 지시서

### 작업 정의
- 증상: [사용자가 설명한 증상]
- 위치: [발생 위치]
- 재현 경로: [재현 방법]

### 필수 확인 사항
1. 에러 로그 확인
   - 브라우저 콘솔
   - 서버 로그
   - 빌드 에러

2. 관련 파일 탐색
   - 증상 발생 컴포넌트
   - 호출되는 API
   - 상태 관리 로직

### 실행 단계

#### Step 1: 버그 재현
- 증거: [실제 에러 메시지 또는 스크린샷]
- 파일: [관련 파일 경로]
- 코드: [문제가 되는 코드 라인]

#### Step 2: 원인 분석
- 직접 원인: [코드 레벨 원인]
- 근본 원인: [설계/로직 레벨 원인]
- 영향 범위: [다른 부분 영향]

#### Step 3: 수정 계획
- 수정 파일: [전체 경로 목록]
- 수정 내용: [구체적 변경 사항]
- 부작용 체크: [영향받는 기능]

#### Step 4: 코드 수정
[전체 파일 내용 포함]
- 수정 전 백업
- 완전한 코드 작성
- 주석으로 변경 사항 표시

#### Step 5: 검증
- 단위 테스트: [테스트 방법]
- 통합 테스트: [전체 플로우 테스트]
- 재현 테스트: [버그 해결 확인]

### 실패시 대응
- 원인을 못 찾은 경우: 더 넓은 범위 조사
- 수정이 안 되는 경우: 다른 접근 방법
- 부작용 발생: 롤백 후 재설계

### 완료 기준
- [ ] 버그 재현 불가
- [ ] 관련 기능 정상 동작
- [ ] 새로운 에러 없음
- [ ] 테스트 통과
```

### 2. UI/UX 개선

```markdown
## UI/UX 개선 지시서

### 작업 정의
- 개선 대상: [구체적 UI 요소]
- 현재 문제: [사용자가 지적한 문제]
- 목표: [개선 목표]
- 참조: [외부 사이트/디자인]

### 필수 확인 사항
1. 현재 구현 확인
   - 컴포넌트 파일
   - 스타일 파일
   - 디자인 시스템

2. 디자인 일관성
   - 색상 팔레트
   - 타이포그래피
   - 컴포넌트 스타일

3. 반응형 디자인
   - 모바일
   - 태블릿
   - 데스크톱

### 실행 단계

#### Step 1: 현재 상태 분석
- 증거: [현재 UI 스크린샷/코드]
- 파일: [관련 컴포넌트 경로]
- 스타일: [현재 적용된 스타일]

#### Step 2: 개선 계획
- 변경 요소: [구체적 요소 목록]
- 디자인 원칙: [따를 원칙]
- 참조 분석: [외부 참조 분석 결과]

#### Step 3: 구현
[전체 컴포넌트 코드]
- 구조 변경
- 스타일 변경
- 애니메이션 추가

#### Step 4: 반응형 체크
- 브레이크포인트별 확인
- 접근성 체크
- 성능 영향 평가

### 완료 기준
- [ ] 디자인 개선 완료
- [ ] 반응형 동작 확인
- [ ] 접근성 기준 충족
- [ ] 성능 저하 없음
```

### 3. 기능 추가

```markdown
## 기능 추가 지시서

### 작업 정의
- 새 기능: [기능 설명]
- 사용 시나리오: [사용자 스토리]
- 기술 요구사항: [필요 기술]

### 필수 확인 사항
1. 기존 구조 확인
   - 유사 기능 존재 여부
   - 재사용 가능 컴포넌트
   - 기존 API 활용 가능성

2. 영향 범위 분석
   - DB 스키마 변경
   - API 추가/수정
   - UI 컴포넌트 추가
   - 상태 관리 변경

### 실행 단계

#### Step 1: 아키텍처 설계
- 데이터 플로우: [입력 → 처리 → 출력]
- 컴포넌트 구조: [계층 구조]
- API 설계: [엔드포인트, 메소드]

#### Step 2: 백엔드 구현
- DB 스키마: [필요시]
- API 라우트: [전체 코드]
- 검증 로직: [입력 검증]
- 에러 처리: [에러 케이스]

#### Step 3: 프론트엔드 구현
- 컴포넌트: [전체 코드]
- 상태 관리: [상태 로직]
- API 연동: [호출 로직]
- UI/UX: [사용자 인터페이스]

#### Step 4: 통합 테스트
- 엔드투엔드 플로우
- 에지 케이스 처리
- 에러 시나리오

### 완료 기준
- [ ] 기능 정상 동작
- [ ] 에러 처리 완료
- [ ] UI 반응형 구현
- [ ] 테스트 작성 완료
```

### 4. API 수정

```markdown
## API 수정 지시서

### 작업 정의
- 수정 대상: [API 경로]
- 변경 내용: [추가/수정/삭제 필드]
- 영향 범위: [프론트엔드, DB]

### 필수 확인 사항
1. 현재 API 구조
   - 요청/응답 형식
   - 인증 방식
   - 에러 처리

2. 데이터베이스
   - 스키마 확인
   - 마이그레이션 필요성
   - 타입 정의

3. 클라이언트 영향
   - API 호출 위치
   - 타입 정의 파일
   - 에러 처리 로직

### 실행 단계

#### Step 1: 현재 구현 분석
- 증거: [현재 API 코드]
- DB 스키마: [관련 테이블]
- 타입 정의: [TypeScript 타입]

#### Step 2: 변경 계획
- DB 마이그레이션: [필요시 SQL]
- API 수정: [변경 사항]
- 타입 업데이트: [새 타입 정의]

#### Step 3: 구현
[전체 API 라우트 코드]
- 요청 검증
- 비즈니스 로직
- 응답 포맷
- 에러 처리

#### Step 4: 클라이언트 수정
- API 호출 코드 수정
- 타입 정의 업데이트
- 에러 처리 수정

#### Step 5: 테스트
- API 직접 테스트
- 통합 테스트
- 하위 호환성 체크

### 완료 기준
- [ ] API 정상 응답
- [ ] 타입 일치
- [ ] 클라이언트 정상 동작
- [ ] 하위 호환성 유지 (필요시)
```

### 5. 성능 최적화

```markdown
## 성능 최적화 지시서

### 작업 정의
- 문제 지점: [느린 부분]
- 현재 성능: [측정값]
- 목표 성능: [목표값]

### 필수 확인 사항
1. 성능 측정
   - 로딩 시간
   - 렌더링 시간
   - API 응답 시간
   - 번들 크기

2. 병목 지점 분석
   - 네트워크 요청
   - 렌더링 최적화
   - 데이터 처리
   - 메모리 사용

### 실행 단계

#### Step 1: 현재 성능 측정
- 증거: [측정 결과]
- 도구: [사용한 도구]
- 병목: [발견된 병목]

#### Step 2: 최적화 전략
- 우선순위: [가장 영향 큰 것부터]
- 방법: [구체적 최적화 방법]
- 예상 개선: [예상 효과]

#### Step 3: 구현
[최적화된 코드]
- 코드 레벨 최적화
- 알고리즘 개선
- 캐싱 전략
- 레이지 로딩

#### Step 4: 성능 재측정
- 개선 결과: [측정값]
- 비교: [이전 vs 이후]
- 부작용: [발생한 부작용]

### 완료 기준
- [ ] 목표 성능 달성
- [ ] 기능 정상 동작
- [ ] 부작용 없음
- [ ] 측정 결과 문서화
```

### 6. 스타일 수정

```markdown
## 스타일 수정 지시서

### 작업 정의
- 수정 대상: [UI 요소]
- 변경 내용: [색상/크기/레이아웃]
- 적용 범위: [단일/전역]

### 필수 확인 사항
1. 스타일 시스템
   - CSS 프레임워크
   - 디자인 토큰
   - 테마 설정

2. 일관성 체크
   - 다른 페이지 스타일
   - 컴포넌트 라이브러리
   - 브랜드 가이드

### 실행 단계

#### Step 1: 현재 스타일 분석
- 증거: [현재 스타일 코드]
- 시스템: [Tailwind/CSS Modules/styled]
- 테마: [라이트/다크 모드]

#### Step 2: 변경 계획
- 변경 요소: [구체적 CSS 속성]
- 영향 범위: [영향받는 컴포넌트]
- 반응형: [브레이크포인트별]

#### Step 3: 구현
[전체 스타일 코드]
- 스타일 변경
- 변수 업데이트
- 반응형 스타일

#### Step 4: 크로스 브라우저 테스트
- Chrome
- Firefox
- Safari
- Edge

### 완료 기준
- [ ] 스타일 적용 완료
- [ ] 반응형 확인
- [ ] 다크모드 지원
- [ ] 크로스 브라우저 호환
```

### 7. 보안 수정

```markdown
## 보안 수정 지시서

### 작업 정의
- 보안 이슈: [취약점 유형]
- 위험도: [Critical/High/Medium/Low]
- 영향 범위: [영향받는 기능]

### 필수 확인 사항
1. 취약점 분석
   - 공격 벡터
   - 영향 범위
   - 악용 가능성

2. 현재 보안 체계
   - 인증/인가
   - 입력 검증
   - 에러 처리

### 실행 단계

#### Step 1: 취약점 확인
- 증거: [취약점 코드/설정]
- 테스트: [재현 방법]
- 영향: [가능한 피해]

#### Step 2: 수정 계획
- 패치 방법: [구체적 수정]
- 영향 평가: [기능 영향]
- 롤백 계획: [문제시 대응]

#### Step 3: 구현
[보안 패치 코드]
- 입력 검증 강화
- 인증 체크 추가
- 에러 메시지 정제
- 로깅 추가

#### Step 4: 보안 테스트
- 취약점 재테스트
- 회귀 테스트
- 펜테스팅 (가능시)

### 완료 기준
- [ ] 취약점 패치 완료
- [ ] 기능 정상 동작
- [ ] 새로운 취약점 없음
- [ ] 보안 테스트 통과
```

### 8. 빌드/배포 이슈

```markdown
## 빌드/배포 이슈 해결 지시서

### 작업 정의
- 문제: [빌드 실패/배포 오류]
- 환경: [로컬/스테이징/프로덕션]
- 에러: [에러 메시지]

### 필수 확인 사항
1. 빌드 환경
   - Node 버전
   - 패키지 버전
   - 환경 변수

2. 빌드 설정
   - 빌드 스크립트
   - 웹팩/Vite 설정
   - TypeScript 설정

### 실행 단계

#### Step 1: 에러 분석
- 증거: [전체 에러 로그]
- 원인: [분석된 원인]
- 관련: [관련 파일/설정]

#### Step 2: 로컬 재현
- 재현 명령: [정확한 명령]
- 결과: [로컬 결과]
- 차이점: [환경 차이]

#### Step 3: 수정
[수정된 설정/코드]
- 설정 파일 수정
- 코드 수정
- 환경 변수 추가

#### Step 4: 검증
- 로컬 빌드 테스트
- CI/CD 파이프라인 테스트
- 배포 테스트

### 완료 기준
- [ ] 빌드 성공
- [ ] 배포 성공
- [ ] 애플리케이션 정상 동작
- [ ] CI/CD 통과
```

### 9. 테스트 추가

```markdown
## 테스트 추가 지시서

### 작업 정의
- 테스트 대상: [기능/컴포넌트]
- 테스트 유형: [단위/통합/E2E]
- 커버리지 목표: [퍼센트]

### 필수 확인 사항
1. 테스트 환경
   - 테스트 프레임워크
   - 테스트 러너
   - 모킹 라이브러리

2. 기존 테스트
   - 테스트 구조
   - 명명 규칙
   - 테스트 패턴

### 실행 단계

#### Step 1: 테스트 계획
- 테스트 케이스: [시나리오 목록]
- 엣지 케이스: [예외 상황]
- 목/스텁: [필요한 모킹]

#### Step 2: 테스트 구현
[전체 테스트 코드]
- Setup
- 테스트 케이스들
- Teardown
- 헬퍼 함수

#### Step 3: 실행 및 검증
- 테스트 실행 결과
- 커버리지 리포트
- 실패 케이스 수정

### 완료 기준
- [ ] 모든 테스트 통과
- [ ] 커버리지 목표 달성
- [ ] CI 통합 완료
- [ ] 문서화 완료
```

### 10. 리팩토링

```markdown
## 리팩토링 지시서

### 작업 정의
- 대상: [리팩토링 대상]
- 목적: [코드 품질/가독성/재사용성]
- 범위: [파일/모듈/전체]

### 필수 확인 사항
1. 현재 코드 분석
   - 코드 복잡도
   - 중복 코드
   - 의존성
   - 테스트 커버리지

2. 리팩토링 영향
   - 영향받는 파일
   - API 변경
   - 동작 변경

### 실행 단계

#### Step 1: 현재 상태 문서화
- 증거: [현재 코드 구조]
- 문제점: [개선 필요 사항]
- 메트릭: [복잡도/중복도]

#### Step 2: 리팩토링 계획
- 변경 전략: [단계별 접근]
- 위험 평가: [리스크와 대응]
- 테스트 전략: [회귀 방지]

#### Step 3: 단계별 구현
[리팩토링된 코드]
- Phase 1: [첫 단계]
- Phase 2: [두번째 단계]
- Phase 3: [마지막 단계]

#### Step 4: 검증
- 기능 테스트: [동작 확인]
- 성능 테스트: [성능 영향]
- 코드 리뷰: [품질 확인]

### 완료 기준
- [ ] 기능 변경 없음
- [ ] 코드 품질 개선
- [ ] 테스트 통과
- [ ] 문서 업데이트
```

---

## ✅ 지시서 작성 완료 체크리스트

```markdown
## AI가 작성한 지시서 검증

### 필수 포함 요소
- [ ] 구체적 파일 경로
- [ ] 전체 코드 (부분 코드 없음)
- [ ] 검증 가능한 단계
- [ ] 실패시 대응 방안
- [ ] 객관적 완료 기준

### 금지 사항 체크
- [ ] 추측이나 가정 없음
- [ ] "일반적으로" 같은 표현 없음
- [ ] "..." 사용 없음
- [ ] 하드코딩된 기술 스택 없음
- [ ] 과도한 의도 추론 없음

### 실행 가능성
- [ ] 모든 단계가 구체적 명령
- [ ] 필요한 정보 모두 포함
- [ ] 검증 방법 명시
- [ ] 롤백 계획 포함
```

---

## 🔴 실패시 정직한 보고 템플릿

```markdown
## 지시서 작성 실패 보고

### 불명확한 부분
1. [구체적으로 무엇이 불명확한지]
2. [어떤 정보가 부족한지]

### 필요한 추가 정보
1. [질문 1: 구체적 질문]
2. [질문 2: 구체적 질문]

### 대안 제시
- 옵션 A: [가능한 해석 1]
- 옵션 B: [가능한 해석 2]

### 사용자 확인 요청
"다음 정보를 제공해 주세요:"
- [필수 정보 1]
- [필수 정보 2]
```

---

*v9.0 - 증거 기반, 완전성 중심의 명확한 지시서 작성 시스템*
*Claude Code의 모든 나쁜 습관 차단 및 100% 실행 가능한 지시서 생성*